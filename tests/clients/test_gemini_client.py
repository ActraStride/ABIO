"""
Module Name: test_gemini_client

Unit tests for the GeminiClient class from the gemini_client module.

This module provides comprehensive test coverage for the GeminiClient class,
including initialization scenarios, API configuration, and error handling.
All tests use mock objects generated by the mock_clients helper module
to avoid actual API calls during testing.

Example:
    Run these tests using pytest or unittest:
    >>> python -m unittest tests.clients.test_gemini_client
    >>> pytest tests/clients/test_gemini_client.py

Dependencies:
    - unittest
    - unittest.mock
    - os
    - sys
    - logging
    - tests.helpers.mock_clients
"""

import unittest
from unittest.mock import patch, MagicMock
import os
import sys
import logging
from typing import Optional, Dict, Any

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from src.clients.gemini_client import GeminiClient
import tests.helpers.mock_clients as mock_helpers

TEST_API_KEY = "test_api_key_from_setup"
TEST_DEFAULT_MODEL_NAME = "gemini-1.5-flash"


class TestGeminiClient(unittest.TestCase):
    """
    Test suite for the GeminiClient class.

    This class contains unit tests that verify the proper initialization,
    configuration, and error handling of the GeminiClient. It uses the
    mock_clients helper module for setting up and tearing down mocks.
    """

    mocks_info: Optional[Dict[str, Any]] = None
    mock_load_dotenv: Optional[MagicMock] = None
    mock_genai: Optional[MagicMock] = None

    def setUp(self) -> None:
        """
        Set up the test environment before each test case using mock_helpers.

        This method:
        - Uses setup_gemini_mocks to patch dependencies (load_dotenv, genai, os.environ)
        - Stores the returned mock information.
        - Extracts relevant mock objects for use in tests.
        - Disables logging during tests to keep test output clean.
        """
        self.mocks_info = mock_helpers.setup_gemini_mocks(api_key=TEST_API_KEY)

        self.mock_load_dotenv = self.mocks_info["mocks"]["load_dotenv"]
        self.mock_genai = self.mocks_info["mocks"]["genai"]

        logging.disable(logging.CRITICAL)

    def tearDown(self) -> None:
        """
        Clean up the test environment after each test case using mock_helpers.

        This method:
        - Uses teardown_gemini_mocks to stop all patchers started in setUp.
        - Re-enables logging for other tests.
        """
        if self.mocks_info:
             mock_helpers.teardown_gemini_mocks(self.mocks_info)

        logging.disable(logging.NOTSET)

    def test_init_missing_api_key(self) -> None:
        """
        Test initialization with a missing API key.

        Verifies that the client raises a ValueError with an appropriate
        message when initialized without an API key in the environment.
        Note: Uses a local patch to override the environment set by setUp.

        Raises:
            AssertionError: If the expected exception is not raised or
                           if the error message doesn't match expectations.
        """
        with patch.dict(os.environ, {}, clear=True):
            with self.assertRaises(ValueError) as context:
                client = GeminiClient()

            self.assertIn("API key must be provided", str(context.exception))

        self.mock_load_dotenv.assert_called_once()
        self.mock_genai.configure.assert_not_called()


    def test_configure_api_success(self) -> None:
        """
        Test successful API configuration using the key from setUp.

        Verifies that the client correctly configures the Gemini SDK
        with the API key provided during mock setup.

        Raises:
            AssertionError: If the SDK is not configured with the correct API key
                           or if load_dotenv is not called.
        """
        client = GeminiClient()

        self.mock_genai.configure.assert_called_once_with(api_key=TEST_API_KEY)
        self.mock_load_dotenv.assert_called_once()

    def test_configure_api_failure(self) -> None:
        """
        Test API configuration failure handling.

        Verifies that the client correctly handles exceptions during API configuration 
        by converting them to RuntimeError with appropriate messages.

        Raises:
            AssertionError: If the exception is not properly caught and re-raised
                           or if the error message doesn't match expectations.
        """
        # Configure the mock to raise an exception when genai.configure is called
        self.mock_genai.configure.side_effect = Exception("SDK configuration error")
        
        # Attempt to initialize the client, which should trigger the exception
        with self.assertRaises(RuntimeError) as context:
            client = GeminiClient()
        
        # Verify the error message
        self.assertIn("Gemini SDK configuration failed", str(context.exception))
        
        # Verify that the original exception is preserved as the cause
        self.assertIsInstance(context.exception.__cause__, Exception)
        self.assertEqual("SDK configuration error", str(context.exception.__cause__))
        
        # Verify that configure was called with the correct API key
        self.mock_genai.configure.assert_called_once_with(api_key=TEST_API_KEY)
        
        # Verify that load_dotenv was called
        self.mock_load_dotenv.assert_called_once()

    def test_list_models_success(self) -> None:
        """
        Test successful retrieval of available models.
        
        Verifies that the client correctly retrieves and filters models
        that support content generation from the Gemini API.
        
        Raises:
            AssertionError: If the models aren't correctly filtered or returned,
                           or if the SDK methods aren't called as expected.
        """
        # Setup mock models with various capabilities
        mock_model1 = MagicMock()
        mock_model1.name = "model-1"
        mock_model1.supported_generation_methods = ["generateContent", "countTokens"]
        
        mock_model2 = MagicMock()
        mock_model2.name = "model-2"
        mock_model2.supported_generation_methods = ["generateContent"]
        
        mock_model3 = MagicMock()
        mock_model3.name = "model-3"
        mock_model3.supported_generation_methods = ["embedContent", "otherMethod"]
        
        # Configure the mock to return our test models
        self.mock_genai.list_models.return_value = [mock_model1, mock_model2, mock_model3]
        
        # Create client and call list_models
        client = GeminiClient()
        result = client.list_models()
        
        # Verify the results - only models with generateContent should be included
        self.assertEqual(["model-1", "model-2"], result)
        
        # Verify that list_models was called exactly once
        self.mock_genai.list_models.assert_called_once()

    def test_list_models_failure(self) -> None:
        """
        Test failure handling when retrieving available models.
        
        Verifies that the client correctly handles exceptions during model listing
        by converting them to RuntimeError with appropriate messages.
        
        Raises:
            AssertionError: If the exception is not properly caught and re-raised
                           or if the error message doesn't match expectations.
        """
        # Configure the mock to raise an exception when list_models is called
        self.mock_genai.list_models.side_effect = Exception("API error")
        
        # Create client and attempt to call list_models
        client = GeminiClient()
        
        # Verify that the exception is caught and re-raised as RuntimeError
        with self.assertRaises(RuntimeError) as context:
            client.list_models()
        
        # Verify the error message
        self.assertIn("Failed to fetch models.", str(context.exception))
        
        # Verify that the original exception is preserved as the cause
        self.assertIsInstance(context.exception.__cause__, Exception)
        self.assertEqual("API error", str(context.exception.__cause__))
        
        # Verify that list_models was called exactly once
        self.mock_genai.list_models.assert_called_once()

    def test_count_tokens_empty_text(self) -> None:
        """
        Test token counting behavior with empty text input.
        
        Verifies that the client correctly raises a ValueError when attempting
        to count tokens in an empty string, validating that input validation
        works as expected before any API calls are made.
        
        Raises:
            AssertionError: If the expected ValueError is not raised or
                           if the error message doesn't match expectations.
        """
        # Create a client instance
        client = GeminiClient()
        
        # Attempt to count tokens with empty text, which should raise ValueError
        with self.assertRaises(ValueError) as context:
            client.count_tokens("")
        
        # Verify the exact error message from the implementation
        self.assertEqual("Text cannot be empty or whitespace.", str(context.exception))
        
        # Verify the GenerativeModel was not instantiated since validation happens first
        self.mock_genai.GenerativeModel.assert_not_called()

    def test_count_tokens_success(self) -> None:
        """
        Test successful token counting operation.
        
        Verifies that the client correctly counts tokens in text using the
        configured model and returns the expected token count from the API.
        
        Raises:
            AssertionError: If the token count doesn't match the expected value,
                           or if the SDK methods aren't called as expected.
        """
        # Configure the mock model instance to return a response with token count
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        
        mock_response = MagicMock()
        mock_response.total_tokens = 10
        mock_model.count_tokens.return_value = mock_response
        
        # Create client and call count_tokens
        client = GeminiClient()
        token_count = client.count_tokens("Hello, world!")
        
        # Verify the token count matches the expected value
        self.assertEqual(10, token_count)
        
        # Verify that GenerativeModel was called with the correct model name
        self.mock_genai.GenerativeModel.assert_called_once_with("gemini-1.5-flash")
        
        # Verify that count_tokens was called with the correct input text
        mock_model.count_tokens.assert_called_once_with("Hello, world!")

    def test_count_tokens_failure(self) -> None:
        """
        Test failure handling when counting tokens.
        
        Verifies that the client correctly handles exceptions during token counting
        by converting them to RuntimeError with appropriate messages.
        
        Raises:
            AssertionError: If the exception is not properly caught and re-raised
                           or if the error message doesn't match expectations.
        """
        # Configure the mock model instance to raise an exception
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        mock_model.count_tokens.side_effect = Exception("API error")
        
        # Create client and attempt to call count_tokens
        client = GeminiClient()
        
        # Verify that the exception is caught and re-raised as RuntimeError
        with self.assertRaises(RuntimeError) as context:
            client.count_tokens("Hello, world!")
        
        # Verify the error message matches the implementation
        self.assertEqual("Failed to count tokens.", str(context.exception))
        
        # Verify that the original exception is preserved as the cause
        self.assertIsInstance(context.exception.__cause__, Exception)
        self.assertEqual("API error", str(context.exception.__cause__))
        
        # Verify that GenerativeModel was called with the correct model name
        self.mock_genai.GenerativeModel.assert_called_once_with("gemini-1.5-flash")
        
        # Verify that count_tokens was called with the correct input text
        mock_model.count_tokens.assert_called_once_with("Hello, world!")

    def test_generate_text_empty_prompt(self) -> None:
        """
        Test text generation with empty prompt input.
        
        Verifies that the client correctly raises a ValueError when attempting
        to generate text with an empty prompt, validating that input validation
        works as expected before any API calls are made.
        
        Raises:
            AssertionError: If the expected ValueError is not raised or
                           if the error message doesn't match expectations.
        """
        # Create a client instance
        client = GeminiClient()
        
        # Attempt to generate text with empty prompt, which should raise ValueError
        with self.assertRaises(ValueError) as context:
            client.generate_text("")
        
        # Verify the exact error message from the implementation
        self.assertEqual("Prompt cannot be empty or whitespace.", str(context.exception))
        
        # Verify the GenerativeModel was not instantiated since validation happens first
        self.mock_genai.GenerativeModel.assert_not_called()

    def test_generate_text_success(self) -> None:
        """
        Test successful text generation operation.
        
        Verifies that the client correctly generates text using the
        specified model and returns a properly formatted RawResponse object.
        
        Raises:
            AssertionError: If the generated text doesn't match expectations,
                           or if the SDK methods aren't called as expected.
        """
        # Configure the mock model instance to return a response with text
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        
        # Mock the count_tokens method to avoid its complexity in this test
        client = GeminiClient()
        client.count_tokens = MagicMock()
        client.count_tokens.return_value = 10  # Mock token count for both prompt and response
        
        # Mock the generate_content response
        mock_response = MagicMock()
        mock_response.text = "Generated response text"
        mock_response.metadata = {"some": "metadata"}
        mock_model.generate_content.return_value = mock_response
        
        # Call generate_text
        result = client.generate_text("Hello, world!")
        
        # Verify the result properties
        self.assertEqual("Generated response text", result.generated_text)
        self.assertEqual(10, result.prompt_tokens)
        self.assertEqual(10, result.response_tokens)
        self.assertEqual("gemini-1.5-flash", result.model_name)
        self.assertEqual({"some": "metadata"}, result.metadata)
        
        # Verify that GenerativeModel was called with the correct model name
        self.mock_genai.GenerativeModel.assert_called_once_with("gemini-1.5-flash")
        
        # Verify that generate_content was called with the correct input text
        mock_model.generate_content.assert_called_once_with("Hello, world!")
        
        # Verify that count_tokens was called twice (once for prompt, once for response)
        self.assertEqual(2, client.count_tokens.call_count)

    def test_generate_text_empty_response(self) -> None:
        """
        Test handling of empty responses from the model.
        
        Verifies that the client correctly raises a RuntimeError when the model
        returns an empty response.
        
        Raises:
            AssertionError: If the exception is not properly raised or
                           if the error message doesn't match expectations.
        """
        # Configure the mock model instance to return an empty response
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        
        # Mock the count_tokens method to avoid its complexity in this test
        client = GeminiClient()
        client.count_tokens = MagicMock()
        client.count_tokens.return_value = 10  # Mock token count
        
        # Mock an empty response
        mock_empty_response = MagicMock()
        mock_empty_response.text = ""  # Empty text
        mock_model.generate_content.return_value = mock_empty_response
        
        # Verify RuntimeError is raised with correct message
        with self.assertRaises(RuntimeError) as context:
            client.generate_text("Hello, world!")
        
        # Verify the error message
        self.assertEqual("Received empty response from the model.", str(context.exception))

    def test_generate_text_model_not_found(self) -> None:
        """
        Test handling when the specified model is not found.
        
        Verifies that the client correctly handles ModelNotFoundError exceptions
        by re-raising them as RuntimeError with appropriate messages.
        
        Raises:
            AssertionError: If the exception is not properly caught and re-raised
                           or if the error message doesn't match expectations.
        """
        # Configure the mock model to raise ModelNotFoundError
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        
        # Mock the count_tokens method to avoid its complexity in this test
        client = GeminiClient()
        client.count_tokens = MagicMock()
        client.count_tokens.return_value = 10
        
        # Create a ModelNotFoundError
        model_error = self.mock_genai.exceptions.ModelNotFoundError("Model not available")
        mock_model.generate_content.side_effect = model_error
        
        # Verify RuntimeError is raised with correct message
        with self.assertRaises(RuntimeError) as context:
            client.generate_text("Hello, world!")
        
        # Verify the error message contains the model name
        self.assertIn(f"Model '{TEST_DEFAULT_MODEL_NAME}' not found", str(context.exception))
        
        # Verify that the original exception is preserved as the cause
        self.assertIs(context.exception.__cause__, model_error)

    def test_generate_text_generation_error(self) -> None:
        """
        Test handling of generation errors from the SDK.
        
        Verifies that the client correctly handles GenerationError exceptions
        by re-raising them as RuntimeError with appropriate messages.
        
        Raises:
            AssertionError: If the exception is not properly caught and re-raised
                           or if the error message doesn't match expectations.
        """
        # Configure the mock model to raise GenerationError
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        
        # Mock the count_tokens method to avoid its complexity in this test
        client = GeminiClient()
        client.count_tokens = MagicMock()
        client.count_tokens.return_value = 10
        
        # Create a GenerationError
        generation_error = self.mock_genai.exceptions.GenerationError("Content generation failed")
        mock_model.generate_content.side_effect = generation_error
        
        # Verify RuntimeError is raised with correct message
        with self.assertRaises(RuntimeError) as context:
            client.generate_text("Hello, world!")
        
        # Verify the error message
        self.assertEqual("Text generation failed due to an SDK error.", str(context.exception))
        
        # Verify that the original exception is preserved as the cause
        self.assertIs(context.exception.__cause__, generation_error)

    def test_generate_text_unexpected_error(self) -> None:
        """
        Test handling of unexpected errors during text generation.
        
        Verifies that the client correctly handles general exceptions
        by re-raising them as RuntimeError with appropriate messages.
        
        Raises:
            AssertionError: If the exception is not properly caught and re-raised
                           or if the error message doesn't match expectations.
        """
        # Configure the mock model to raise an unexpected exception
        mock_model = MagicMock()
        self.mock_genai.GenerativeModel.return_value = mock_model
        
        # Mock the count_tokens method to avoid its complexity in this test
        client = GeminiClient()
        client.count_tokens = MagicMock()
        client.count_tokens.return_value = 10
        
        # Create an unexpected exception
        unexpected_error = Exception("Unexpected failure")
        mock_model.generate_content.side_effect = unexpected_error
        
        # Verify RuntimeError is raised with correct message
        with self.assertRaises(RuntimeError) as context:
            client.generate_text("Hello, world!")
        
        # Verify the error message
        self.assertEqual("An unexpected error occurred during text generation.", str(context.exception))
        
        # Verify that the original exception is preserved as the cause
        self.assertIs(context.exception.__cause__, unexpected_error)

if __name__ == '__main__':
    unittest.main()